# IVXP/1.0 Security

This document describes the cryptographic and security requirements for the IVXP/1.0 protocol.

## Identity Authentication: EIP-191 Signatures

IVXP uses [EIP-191](https://eips.ethereum.org/EIPS/eip-191) (version 0x45, `personal_sign`) for wallet-based identity authentication. No passwords, API keys, or OAuth tokens are required.

### How It Works

1. Client constructs a deterministic message string
2. Client signs the message with their Ethereum private key using `personal_sign`
3. Provider recovers the signer address from the signature
4. Provider verifies the recovered address matches the claimed `from_address`

### Signed Message Format

For delivery requests, the signed message follows this format:

```
IVXP-DELIVER | Order: {order_id} | Payment: {tx_hash} | Nonce: {nonce} | Timestamp: {timestamp}
```

| Field          | Description                                                               |
| -------------- | ------------------------------------------------------------------------- |
| `IVXP-DELIVER` | Fixed prefix to prevent cross-protocol replay                             |
| `order_id`     | The order identifier from the quote                                       |
| `tx_hash`      | The on-chain transaction hash                                             |
| `nonce`        | A unique random string (min 16 chars) generated by the client per request |
| `timestamp`    | ISO 8601 timestamp of the delivery request                                |

Example:

```
IVXP-DELIVER | Order: ivxp-550e8400-e29b-41d4-a716-446655440000 | Payment: 0xabcdef...7890 | Nonce: a1b2c3d4e5f6g7h8 | Timestamp: 2026-02-05T12:05:00Z
```

The `nonce` field prevents replay attacks even if the same `order_id` and `tx_hash` are reused across different sessions. Providers MUST track seen nonces per order and reject duplicates.

### Signature Format

- Algorithm: ECDSA on secp256k1 (Ethereum standard)
- Encoding: Hex with `0x` prefix
- Length: 132 characters (0x + 130 hex chars = 65 bytes: r[32] + s[32] + v[1])
- Pattern: `^0x[a-fA-F0-9]{130}$`

### Verification Process

```
1. message = "IVXP-DELIVER | Order: {order_id} | Payment: {tx_hash} | Nonce: {nonce} | Timestamp: {timestamp}"
2. prefixed = "\x19Ethereum Signed Message:\n" + len(message) + message
3. hash = keccak256(prefixed)
4. recovered_address = ecrecover(hash, signature)
5. assert recovered_address == from_address
6. assert nonce has not been seen before for this order_id
7. assert timestamp is within MAX_TIMESTAMP_AGE of current time
```

---

## Payment Verification

IVXP uses on-chain USDC transfers on Base L2 for payment. The provider verifies payments by reading the blockchain directly.

### Supported Networks

| Network      | NetworkId      | Chain ID | USDC Contract                                |
| ------------ | -------------- | -------- | -------------------------------------------- |
| Base Mainnet | `base-mainnet` | 8453     | `0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913` |
| Base Sepolia | `base-sepolia` | 84532    | `0x036CbD53842c5426634e7929541eC2318f3dCF7e` |

### USDC Token Details

- Standard: ERC-20
- Decimals: 6
- Raw amount: `amount_usdc * 10^6` (e.g., 5.0 USDC = `5000000`)

### Verification Steps

The provider performs these checks when verifying a payment:

1. **Transaction exists:** The `tx_hash` must correspond to a confirmed transaction on the specified network
2. **Correct recipient:** The transaction's `to` address must match the `payment_address` from the quote
3. **Sufficient amount:** The transferred amount must be >= the `price_usdc` from the quote
4. **Correct token:** The transaction must be a USDC transfer (correct token contract)
5. **Correct sender:** The `from` address must match the client's `wallet_address`

### Payment Proof

The `PaymentProof` object in the `DeliveryRequest` provides:

```json
{
  "tx_hash": "0x...",
  "from_address": "0x...",
  "network": "base-sepolia",
  "to_address": "0x...",
  "amount_usdc": "5000000",
  "block_number": 12345678
}
```

Required fields: `tx_hash`, `from_address`, `network`
Optional fields: `to_address`, `amount_usdc`, `block_number` (provider verifies on-chain regardless)

---

## Threat Model

### Replay Attacks

**Mitigation:** Each delivery request includes a unique `order_id`, a `nonce`, and a `timestamp`. The provider:

1. Tracks processed nonces per `order_id` and rejects duplicates
2. Validates timestamp freshness (see Timestamp Freshness below)
3. Rejects delivery requests for already-processed orders (`DUPLICATE_DELIVERY_REQUEST`)

### Signature Forgery

**Mitigation:** EIP-191 signatures are cryptographically bound to the signer's private key. The provider recovers the signer address and verifies it matches the payment sender.

### Payment Front-Running

**Mitigation:** The `order_id` is bound to a specific client wallet address. Even if a third party observes the payment, they cannot claim the deliverable without the client's signature.

### Man-in-the-Middle

**Mitigation:** All IVXP endpoints must use HTTPS (TLS 1.2+). The protocol does not define its own transport encryption; it relies on TLS.

### Double-Spending

**Mitigation:** The provider verifies payments on-chain after block confirmation. The `tx_hash` is unique per transaction and cannot be reused.

---

## Transport Security

- All IVXP endpoints MUST be served over HTTPS
- TLS 1.2 or higher is required
- Providers SHOULD use HSTS headers
- Providers SHOULD implement rate limiting on all endpoints

## Timestamp Freshness

All IVXP messages with a `timestamp` field MUST be validated for freshness to prevent replay attacks using old messages.

### Requirements

| Parameter           | Value                   | Description                                |
| ------------------- | ----------------------- | ------------------------------------------ |
| `MAX_TIMESTAMP_AGE` | 300 seconds (5 minutes) | Maximum age of a message timestamp         |
| `MAX_CLOCK_SKEW`    | 60 seconds (1 minute)   | Maximum allowed clock skew into the future |

### Validation Rules

Providers MUST reject messages where:

- `timestamp` is older than `now - MAX_TIMESTAMP_AGE` (message too old)
- `timestamp` is newer than `now + MAX_CLOCK_SKEW` (clock skew too large)

```
current_time = now()
message_age = current_time - parse(timestamp)

if message_age > MAX_TIMESTAMP_AGE:
    reject with INVALID_TIMESTAMP ("Message timestamp too old")

if message_age < -MAX_CLOCK_SKEW:
    reject with INVALID_TIMESTAMP ("Message timestamp in the future")
```

### Clock Synchronization

- Providers SHOULD use NTP for clock synchronization
- Clients SHOULD use NTP for clock synchronization
- The `MAX_CLOCK_SKEW` tolerance accounts for minor clock drift between parties

## Content Integrity

The `content_hash` field in `DeliveryResponse` provides integrity verification for the delivered content.

### Hash Algorithm

- Algorithm: SHA-256
- Output format: `sha256:{hex-encoded-hash}` (lowercase hex, 64 characters)
- Pattern: `^sha256:[a-f0-9]{64}$`

### Hash Input

The hash is computed over the serialized deliverable content:

```
input = JSON.stringify(deliverable.content)
hash = SHA-256(input)
content_hash = "sha256:" + hex(hash)
```

For string content, `JSON.stringify` produces a quoted string. For object/array content, it produces the JSON representation.

### Validation Requirements

- Providers MUST compute and include `content_hash` in all `DeliveryResponse` messages
- Clients MUST verify the `content_hash` matches the delivered content before processing
- If the hash does not match, the client MUST discard the deliverable and report the mismatch

## Wallet Address Validation

- All Ethereum addresses must match the pattern `^0x[a-fA-F0-9]{40}$`
- The protocol normalizes addresses to lowercase for comparison
- Checksummed addresses (EIP-55) are accepted but not required
